\documentclass[10pt, onecolumn, draftclsnofoot, letterpaper, compsoc]{IEEEtran}

\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{alltt}
%\usepackage{float}
\usepackage{color}
\usepackage{url}
\usepackage{minted}

\renewcommand*\contentsname{Table of Contents} % Rename ToC

% Temp title and author
\title{Progress Report}
\author{Totality AweSun \\
		Bret~Lorimore, Jacob~Fenger, George~Harder \\
		\textit{\today \\
		CS 461 - Fall 2016}}

\begin{document}

\maketitle

\begin{abstract}

Text

\end{abstract}

\newpage

\tableofcontents

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%
%   Project Overview   %
%%%%%%%%%%%%%%%%%%%%%%%%
\section{Project Overview}

Text

\subsection{Image Processor}

Text

\subsection{Image Processor Manager}

The image processor manager will be a Python application responsible for managing the image processor
application. This includes collecting images from Google Cloud for the image processor to process,
invoking the image processor with these images as input, and collecting the output of the image
processor and uploading it to Google Cloud. The image processor and image processor manager will be
deployed together in a single docker container to Google Container Engine Clusters (of VMs). \\

An important role of the image processor manager is that it will be responsible for ensuring that
the compute resources on the host VMs are as saturated as possible. This means invoking multiple
image processor processes concurrently, while at the same time downloading the next images to be
processed and uploading the already processed images. The image processor manager will achieve
this parallelism through process based concurrency in Python, as in Python, thread based concurrency
is throttled by the global interpreter lock (GIL). We chose to use Python for this application as it
will be much simpler to write in Python and we can sidestep any concurrency issues by using process
based parallelism as mentioned above. \\

\subsection{Eclipse Simulator}

The eclipse simulator will be an independent JavaScript module that can easily
be added to the existing Eclipse Megamovie webpage. This simulator will allow
users to “preview” the eclipse. It will be a 2D depiction of what the solar
eclipse in 2017 could look like given a certain location. Users will be able
to interact with a time slider that will simulate the eclipse in a time
window spanning from 12 hours before the eclipse to 12 hours after it.

To help with the eclipse ephemeris computations, we will be using an external
JavaScript library called Ephemeris. For the front end view for the simulator,
we will be utilizing HTML5 SVG. We plan to implement a model-view-controller
architecture for controlling the states of each component as well as handling
the interactions. This architecture was chosen due to the ability to easily
exchange a component without altering the whole design of the system. For
example, if one wanted to create a whole new front end for the simulator,
they would not need to rewrite the model or controller component of the system.
They would simply need to ensure that the new view component can handle the
interactions with the controller module.


%%%%%%%%%%%%%%%%%%%%%%%%
%   Current Status     %
%%%%%%%%%%%%%%%%%%%%%%%%
\section{Current Status of the Project}

Text

\subsection{Image Processor}

Text

\subsection{Image Processor Manager}

Development has yet to start on the image processor manager, but we have a very good idea of how we
are going to build it. Additionally, we will have access to code that Bret wrote during his internship
this summer that we will be able to repurpose to handle large parts of the interactions with Google Cloud.

\subsection{Eclipse Simulator}

As it currently stands, progress has been made to create an initial working
demo of the simulator. We have worked with the Ephemeris library to see how
accurate its computations are. There was some variance when comparing the
values it returned to other 2017 solar eclipse predictions, but we have
decided that the variance is not large enough to warrant worry. Work has
been done to create a front end view for the simulator. Eventually Google
will be providing the sprites that the simulator will use, but we are currently
just using simple SVG circles to simulate the Sun and Moon. We also have the
code to render these Sun and Moon SVGs on the eclipse simulator window given
their altitude and azimuth (vertical/horizontal angular coordinates). We will
continue working on the eclipse simulator over winter break.

%%%%%%%%%%%%%%%%%%%%%%%%
%   Problems           %
%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problems and Possible Solutions}

Around week 8 of the term, we found that some results differed in the Ephemeris
library calculations and eclipse predictions we found elsewhere. We brought
this issue up with our client, and he said to continue progress on the
simulator as the variance we were seeing was not very significant for the
simulator. Once further progress has been made on the simulator, it may be
necessary to dig into the Ephemeris code base to determine any problems.

%%%%%%%%%%%%%%%%%%%%%%%%
%   Code               %
%%%%%%%%%%%%%%%%%%%%%%%%
\section{Interesting Code}

\begin{minted}{javascript}
// EclipseSimulator namespace
var EclipseSimulator = {

   // [...]

    View: function()
    {
        this.window   = $('#container').get(0);
        this.controls = $('#controls').get(0);
        this.sun      = $('#sun').get(0);
        this.moon     = $('#moon').get(0);

      // temp radius values
        this.sunpos  = {x: 50, y: 50, r: 2 * Math.PI / 180};
        this.moonpos = {x: 25, y: 25, r: 2 * Math.PI / 180};

        // Field of view in radians
        this.fov = {x: 80 * Math.PI / 180, y: 80 * Math.PI / 180};

        // Center of frame in radians
        this.az_center = 0 * Math.PI / 180;
    },

    // [...]

    // Convert degrees to radians
    deg2rad: function(v)
    {
        return v * Math.PI / 180;
    },

    // Convert radians to degrees
    rad2deg: function(v)
    {
        return v * 180 / Math.PI;
    },

    // Convert a to be on domain [0, 2pi)
    normalize_rad: function(a)
    {
        var pi2 = Math.PI * 2;
        return a - (pi2 * Math.floor(a / pi2));
    },

    // Compute positive distance in radians between two angles
    rad_diff: function(a1, a2)
    {
        a1 = EclipseSimulator.normalize_rad(a1);
        a2 = EclipseSimulator.normalize_rad(a2);

        var diff = a1 > a2 ? (a1 - a2) : (a2 - a1);

        return diff > Math.PI ? (2 * Math.PI) - diff : diff;
    },

    // Determine if angle a is greater than angle b
    // That is, if b < a <= (b + pi)
    rad_gt: function(a, b)
    {
        a = EclipseSimulator.normalize_rad(a);
        b = EclipseSimulator.normalize_rad(b);

        a = EclipseSimulator.normalize_rad(a - b);
        b = 0;

        return a > b && a <= Math.PI;
    },

    // [...]
};

// [...]


EclipseSimulator.View.prototype.get_x_percent_from_az = function(az, radius)
{
    var dist_from_center = Math.sin(az - this.az_center);
    var half_fov_width   = Math.sin(this.fov.x / 2);

    if (this.az_out_of_view(az, radius))
    {
        // Just move the body way way off screen
        dist_from_center += this.fov.x * 10;
    }

    return 50 + (50 * dist_from_center / half_fov_width);
}

// This may need some re-visiting... the current computations imply a field of
// view of 2*fov.y
// Compute y coordinate in simulator window as a percentage of the window
// height
// Assumes altitude is <= (pi/2)
EclipseSimulator.View.prototype.get_y_percent_from_alt = function(alt)
{
    var height     = Math.sin(alt);
    var fov_height = Math.sin(this.fov.y);

    return 100 * height / fov_height;
}

EclipseSimulator.View.prototype.az_out_of_view = function(az, radius)
{
    var bound = this.az_center + (this.fov.x / 2);
    var dist  = EclipseSimulator.rad_diff(bound, az);
    // Body off screen to the right
    if (EclipseSimulator.rad_gt(az, bound) && dist > radius)
    {
        return true;
    }

    bound = this.az_center - (this.fov.x / 2);

    dist  = EclipseSimulator.rad_diff(bound, az);

    // Body off screen to the left
    if (EclipseSimulator.rad_gt(bound, az) && dist > radius)
    {
        return true;
    }

    return false;
}

// [...]
\end{minted}

%%%%%%%%%%%%%%%%%%%%%%%%
%   Weekly Summary     %
%%%%%%%%%%%%%%%%%%%%%%%%
\section{Week by Week Summary of Group Activities}

\subsection{Week 1}

\begin{itemize}

\item Text

\end{itemize}

\subsection{Week 2}

\begin{itemize}

\item Text

\end{itemize}

\subsection{Week 3}

\begin{itemize}

\item Text

\end{itemize}

\subsection{Week 4}

\begin{itemize}

\item Text

\end{itemize}

\subsection{Week 5}

\begin{itemize}

\item Text

\end{itemize}

\subsection{Week 6}

\begin{itemize}

\item Text

\end{itemize}

\subsection{Week 7}

\begin{itemize}

\item Text

\end{itemize}

\subsection{Week 8}

\begin{itemize}

\item Text

\end{itemize}

\subsection{Week 9}

\begin{itemize}

\item Text

\end{itemize}

\subsection{Week 10}

\begin{itemize}

\item Text

\end{itemize}

\section{Retrospectives}

\begin{table}[h]
    \centering
    \begin{tabular}{|p{.3\linewidth}|p{.3\linewidth}|p{.3\linewidth}|}

    \cline{3-3}

    \hline \textbf{Positives} & \textbf{Deltas} & \textbf{Actions} \\ \hline

    Image Processor design completed &  & \\ \hline
    Image Processor Manager design completed &  & \\ \hline
    Began work on Eclipse Simulator & User interaction & Implement buttons to alter sun/moon positions \\ \hline

    Have access to Solar Eclipse Image Standardisation and Sequencing algorithm, research paper and code
    & Existing code is written in IDL and the algorithm does not completely meet our needs at this point in time
    & Port code to C++ and modify algorithm to meet our needs \\ \hline

    Have reusable code from Bret’s internship that is relevant to both the Image Processor and Image Processor Manager
    & Need to work on re-purposing this code to fit our needs and incorporate into our project
    & Need to work with sponsor to get this code open sourced \\ \hline

    Sponsor impressed by proposed usage of EXIF GPS data in Image Processor &  & \\ \hline


    \end{tabular}
\end{table}

\end{document}
