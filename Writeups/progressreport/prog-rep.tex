\documentclass[10pt, onecolumn, draftclsnofoot, letterpaper, compsoc]{IEEEtran}

\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{alltt}
%\usepackage{float}
\usepackage{color}
\usepackage{url}
\usepackage{minted}

\renewcommand*\contentsname{Table of Contents} % Rename ToC

% Temp title and author
\title{Progress Report}
\author{Totality AweSun \\
		Bret~Lorimore, Jacob~Fenger, George~Harder \\
		\textit{\today \\
		CS 461 - Fall 2016}}

\begin{document}

\maketitle

\begin{abstract}

Text

\end{abstract}

\newpage

\tableofcontents

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%
%   Project Overview   %
%%%%%%%%%%%%%%%%%%%%%%%%
\section{Project Overview}

Text

\subsection{Image Processor}

Text

\subsection{Image Processor Manager}

The image processor manager will be a Python application responsible for managing the image processor
application. This includes collecting images from Google Cloud for the image processor to process, 
invoking the image processor with these images as input, and collecting the output of the image 
processor and uploading it to Google Cloud. The image processor and image processor manager will be 
deployed together in a single docker container to Google Container Engine Clusters (of VMs). \\

An important role of the image processor manager is that it will be responsible for ensuring that 
the compute resources on the host VMs are as saturated as possible. This means invoking multiple 
image processor processes concurrently, while at the same time downloading the next images to be 
processed and uploading the already processed images. The image processor manager will achieve 
this parallelism through process based concurrency in Python, as in Python, thread based concurrency 
is throttled by the global interpreter lock (GIL). We chose to use Python for this application as it 
will be much simpler to write in Python and we can sidestep any concurrency issues by using process 
based parallelism as mentioned above. \\

\subsection{Eclipse Simulator}

Text


%%%%%%%%%%%%%%%%%%%%%%%%
%   Current Status     %
%%%%%%%%%%%%%%%%%%%%%%%%
\section{Current Status of the Project}

Text

\subsection{Image Processor}

Text

\subsection{Image Processor Manager}

Development has yet to start on the image processor manager, but we have a very good idea of how we 
are going to build it. Additionally, we will have access to code that Bret wrote during his internship 
this summer that we will be able to repurpose to handle large parts of the interactions with Google Cloud.

\subsection{Eclipse Simulator}

Text

%%%%%%%%%%%%%%%%%%%%%%%%
%   Problems           %
%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problems and Possible Solutions}

Text

%%%%%%%%%%%%%%%%%%%%%%%%
%   Code               %
%%%%%%%%%%%%%%%%%%%%%%%%
\section{Interesting Code}

Below are some interesting sections of the Eclipse Simulator view code that we have so far. 
The code shown below focuses on rendering the Sun and Moon on the screen given their
altitude and azimuth. \\

\begin{minted}{javascript}
// EclipseSimulator namespace
var EclipseSimulator = {

   // [...]

    View: function()
    {
        this.window   = $('#container').get(0);
        this.controls = $('#controls').get(0);
        this.sun      = $('#sun').get(0);
        this.moon     = $('#moon').get(0);

      // temp radius values
        this.sunpos  = {x: 50, y: 50, r: 2 * Math.PI / 180};
        this.moonpos = {x: 25, y: 25, r: 2 * Math.PI / 180};

        // Field of view in radians
        this.fov = {x: 80 * Math.PI / 180, y: 80 * Math.PI / 180};

        // Center of frame in radians
        this.az_center = 0 * Math.PI / 180;
    },

    // [...]

    // Convert degrees to radians
    deg2rad: function(v)
    {
        return v * Math.PI / 180;
    },

    // Convert radians to degrees
    rad2deg: function(v)
    {
        return v * 180 / Math.PI;
    },

    // Convert a to be on domain [0, 2pi)
    normalize_rad: function(a)
    {
        var pi2 = Math.PI * 2;
        return a - (pi2 * Math.floor(a / pi2));
    },

    // Compute positive distance in radians between two angles
    rad_diff: function(a1, a2)
    {
        a1 = EclipseSimulator.normalize_rad(a1);
        a2 = EclipseSimulator.normalize_rad(a2);

        var diff = a1 > a2 ? (a1 - a2) : (a2 - a1);

        return diff > Math.PI ? (2 * Math.PI) - diff : diff;
    },

    // Determine if angle a is greater than angle b
    // That is, if b < a <= (b + pi) 
    rad_gt: function(a, b)
    {
        a = EclipseSimulator.normalize_rad(a);
        b = EclipseSimulator.normalize_rad(b);

        a = EclipseSimulator.normalize_rad(a - b);
        b = 0;

        return a > b && a <= Math.PI;
    },

    // [...]
};

// [...]


EclipseSimulator.View.prototype.get_x_percent_from_az = function(az, radius)
{
    var dist_from_center = Math.sin(az - this.az_center);
    var half_fov_width   = Math.sin(this.fov.x / 2);

    if (this.az_out_of_view(az, radius))
    {
        // Just move the body way way off screen
        dist_from_center += this.fov.x * 10;
    }

    return 50 + (50 * dist_from_center / half_fov_width);
}

// This may need some re-visiting... the current computations imply a field of
// view of 2*fov.y
// Compute y coordinate in simulator window as a percentage of the window 
// height
// Assumes altitude is <= (pi/2)
EclipseSimulator.View.prototype.get_y_percent_from_alt = function(alt)
{
    var height     = Math.sin(alt);
    var fov_height = Math.sin(this.fov.y);

    return 100 * height / fov_height;
}

EclipseSimulator.View.prototype.az_out_of_view = function(az, radius)
{
    var bound = this.az_center + (this.fov.x / 2);
    var dist  = EclipseSimulator.rad_diff(bound, az);
    // Body off screen to the right
    if (EclipseSimulator.rad_gt(az, bound) && dist > radius)
    {
        return true;
    }

    bound = this.az_center - (this.fov.x / 2);
    
    dist  = EclipseSimulator.rad_diff(bound, az);
    
    // Body off screen to the left
    if (EclipseSimulator.rad_gt(bound, az) && dist > radius)
    {
        return true;
    }
    
    return false;
}

// [...]
\end{minted}

%%%%%%%%%%%%%%%%%%%%%%%%
%   Weekly Summary     %
%%%%%%%%%%%%%%%%%%%%%%%%
\section{Week by Week Summary of Group Activities}

\subsection{Week 1}

    \begin{itemize}

    \item Go to class

    \end{itemize}

\subsection{Week 2}

    \begin{itemize}

    \item Worked on initial draft of problem statement.

    \item Established a LaTeX workflow.

    \end{itemize}

\subsection{Week 3}

    \begin{itemize}

    \item Got feedback from sponsor and Kirstin on initial problem statement 
    draft. Our sponsor was happy with our initial draft. Kirstin informed us that 
    our problem statement was actually a bit too verbose and covered a lot of 
    material that was more relevant to the technology review.

    \end{itemize}

\subsection{Week 4}

    \begin{itemize}

    \item Had an initial meeting with Vee, our TA.

    \item Researched rotation matrices and quaternions at the suggestion of our 
    sponsor. He pointed us to this material as being relevant to our rotating 
    images, but likely more involved than actually necessary. He still encouraged 
    us to research the material as he thought it was interesting and good to 
    know. It was!

    \end{itemize}

\subsection{Week 5}

    \begin{itemize}

    \item Created initial requirements document draft.

    \end{itemize}

\subsection{Week 6}

    \begin{itemize}

    \item Reviewed requirements document with project sponsor.

    \item Followed up on new information we received from our client in week 5, 
    specifically that we would have access to GPS/timestamp EXIF info in the 
    image processor. We considered this and proposed a scheme to incorporate it 
    into the image processor that our client was very happy with.

    \end{itemize}

\subsection{Week 7}

    \begin{itemize}

    \item Our sponsor added an additional component to the project, the image 
    processor manager. Previously this had been outside the scope of the project. 
    We were initially hesitant about taking this on, but realized that there was 
    some relevant code from Bretâ€™s internship over the summer that we can 
    repurpose for this component of the project.

    \end{itemize}

\subsection{Week 8}

    \begin{itemize}

    \item Began work on the eclipse simulator. We ran into some issues computing 
    accurate sun/moon positions using JavaScript. The first library we were 
    using, SunCalc was not producing accurate results. After switching to the 
    Ephemeris library, we started seeing better results.

    \end{itemize}

\subsection{Week 9}

    \begin{itemize}

    \item Met as a group and ironed out a high level design for the various 
    components of the project. 

    \item Individually began working on our respective design document pieces.

    \item Continued to see accuracy issues with eclipse calculations in 
    JavaScript, even after switching to Ephemeris. We spoke to our sponsor about 
    this and he recommended moving on for the time being, as he did not think 
    these computations were off enough to warrant concern, or even render them 
    unusable.

    \end{itemize}

\subsection{Week 10}

    \begin{itemize}

    \item Completed and turned in design document, we struggled a bit 
    interpreting the IEEE 1016 standard for the design document.

    \item Began work on the view code for the eclipse simulator.

    \end{itemize}

\newpage
\section{Retrospectives}

\begin{table}[h]
    \centering
    \begin{tabular}{|p{.3\linewidth}|p{.3\linewidth}|p{.3\linewidth}|}

    \cline{3-3}

    \hline \textbf{Positives} & \textbf{Deltas} & \textbf{Actions} \\ \hline

    Image Processor design completed &  & \\ \hline
    Image Processor Manager design completed &  & \\ \hline
    Began work on Eclipse Simulator & User interaction & Implement buttons to alter sun/moon positions \\ \hline

    Have access to Solar Eclipse Image Standardisation and Sequencing algorithm, research paper and code
    & Existing code is written in IDL and the algorithm does not completely meet our needs at this point in time
    & Port code to C++ and modify algorithm to meet our needs \\ \hline

    Have reusable code from Bretâ€™s internship that is relevant to both the Image Processor and Image Processor Manager
    & Need to work on re-purposing this code to fit our needs and incorporate into our project
    & Need to work with sponsor to get this code open sourced \\ \hline

    Sponsor impressed by proposed usage of EXIF GPS data in Image Processor &  & \\ \hline


    \end{tabular}
\end{table}

\end{document}